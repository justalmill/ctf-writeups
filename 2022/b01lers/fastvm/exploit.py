from pwn import *

p = process("python cpu.py", shell=True)
#p = remote("ctf.b01lers.com", 9204)


# 51 instructions long, needed to be <= 55 instructions
# works 1/8 times because I always add then shift when decoding the values will always come out even 
asm = """
# init some constants
movc r8 4 # actual count
movc r4 2 # set multiply to 2
movc r5 1 # set increment to 1

# jmp to part 2 if reset
movfrom r1 0 r9
mov r0 r1
jmpz 18

# set constants, need to loop through each bit of each random value
movc r6 32 # loop stop
movc r2 1 # set bit counter init
movc r3 0 # set counter init

mov r0 r2 # copy counter for and
and r0 r1 # and values
jmpz 2 # if 0 don't set
movfrom r0 0 r8 # make a dict entry at counter
mul r2 r4 # shift left
add r3 r5 # increment
add r8 r5 # increment
mov r0 r6
sub r0 r3
jmpg r7 -9 # jmp to read next bit
add r9 r5
movc r0 4
jmpg r9 -20 # jmp to read next rand

reset
jmp 15 # jmp to loop end

# get time before and after movfrom
time
mov r1 r0
movfrom r0 4 r3
time

# check if value was in dictionary already
sub r0 r1
movc r1 3 # if greater than 3 then it wasn't in the original
jmpg r1 2
add r9 r5 # if it was there, increment and shift 
mul r9 r4 # if it wasn't then just shift

sub r3 r5 # decrement counter
mov r0 r3
jmpg r8 -11 # check next bit

movto r9 1000 r6 # store result

add r6 r5 # increment index

movc r8 32 # set end position for next
mul r8 r6 # set end position for next

mov r3 r8
movc r0 32
add r3 r0  # set start position for next

movc r9 0

movc r0 4
jmpg r6 -21

movfrom r0 1000 r9
movfrom r1 1001 r9
movfrom r2 1002 r9
movfrom r3 1003 r9
magic



"""

p.sendline(asm)

p.recvuntil("Registers: [")
regs = p.recvline()[:-2]
splitr = regs.split(b", ")
print(splitr)
for s in splitr:
    print(hex(int(s)))